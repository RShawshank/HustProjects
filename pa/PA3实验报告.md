# PA3实验报告

## 要求

- 实现自陷操作`_yield()`及其过程

- 实现用户程序的加载和系统调用，支撑TRM程序运行

- 运行仙剑奇侠传并展示批处理系统

## 知识点

### 最简单的操作系统

- 注意Nanos-lite是运行在AM之上的，即AM的API在Nanos-lite中都是可用的。
- Nanos-lite目前的行为
  - 打印Project-N的logo, 并通过`Log()`输出hello信息和编译时间.
    - Nanos-lite和NEMU是两个独立的项目, 它们的代码不会相互影响
  - 初始化ramdisk
    - Nanos-lite把其中的一段内存作为磁盘来使用
  - 调用`init_device()`对设备进行一些初始化操作
  - `init_fs()`和`init_proc()`, 分别用于初始化文件系统和创建进程
  - 调用`panic()`结束Nanos-lite的运行
- Nanos-lite本质上也是一个AM程序

要实现一个最简单的操作系统, 就要实现以下两点功能:

- 用户程序执行结束之后, 可以跳转到操作系统的代码继续执行
- 操作系统可以加载一个新的用户程序来执行

### 等级森严的制度

- 出于对OS的保护，限制用户程序对执行流的随意切换

- riscv32则有机器模式, 监控者模式和用户模式
  - 操作系统运行在监控者模式, 用户进程运行在用户模式
  - 这些保护都是通过硬件实现的

- 保护机制需要软硬件配合，有很多细节。对于NEMU，目前暂时不需要保护机制，即所有用户进程都运行在最高特权级。
- 除此之外，执行流切换本身还要实现。OS加载用户程序好说，而用户程序切换回OS则比较麻烦，因为要切换到一个相对固定的位置。ISA使用**自陷**来实现这一操作。
  - 程序执行自陷指令后，OS会跳转到异常入口地址
  - riscv32提供`ecall`指令作为自陷指令, 并提供一个stvec寄存器来存放异常入口地址
  -  为了保存程序当前的状态, riscv32提供了一些特殊的系统寄存器, 叫控制状态寄存器(CSR寄存器). 在PA中, 我们只使用如下3个CSR寄存器:
    - sepc寄存器 - 存放触发异常的PC
    - sstatus寄存器 - 存放处理器的状态
    - scause寄存器 - 存放触发异常的原因
  - riscv32触发异常后硬件的响应过程如下:
    1. 将当前PC值保存到sepc寄存器
    2. 在scause寄存器中设置异常号
    3. 从stvec寄存器中取出异常入口地址
    4. 跳转到异常入口地址
  - **值得强调的是上述过程都是由硬件自动完成的**
- riscv32通过`sret`指令从异常处理过程中返回, 它将根据sepc寄存器恢复PC.

### 将上下文管理抽象成CTE

将上下文管理的功能划入到AM的一类新的API中, 名字叫CTE(ConText Extension).

- riscv32中通过`ecall`指令来进行自陷
- 首先当然是引发这次执行流切换的原因
  - CTE将其抽象为“事件”`_Event`，定义在`am.h`
  - 目前只需要事件编号。不同的架构只需用同一编号描述同一原因即可。
    - `cause`和`ref`是一些描述事件的补充信息, `msg`是事件信息字符串
- 然后可能要保存程序的上下文（一些寄存器），OS可能会根据这些信息进一步处理。
- 最后还有另外两个统一的API:
  - `int _cte_init(_Context* (*handler)(_Event ev, _Context *ctx))`用于进行CTE相关的初始化操作. 其中它还接受一个来自操作系统的事件处理回调函数的指针, 当发生事件时, CTE将会把事件和相关的上下文作为参数, 来调用这个回调函数, 交由操作系统进行后续处理.
  - `void _yield()`用于进行自陷操作, 会触发一个编号为`_EVENT_YIELD`事件. 不同的ISA会使用不同的自陷指令来触发自陷操作。

### 设置异常入口地址

放入CTE中实现。

- 在`nanos-lite/include/common.h`中定义宏`HAS_CTE`, 这样以后, Nanos-lite会多进行一项初始化工作: 调用`init_irq()`函数, 这最终会调用位于`nexus-am/am/src/$ISA/nemu/cte.c`中的`_cte_init()`函数
  - `_cte_init()`函数功能之一：设置异常入口地址
    - 对于riscv32来说, 直接将异常入口地址设置到stvec寄存器中即可
  - `_cte_init()`函数功能之二：注册一个事件处理回调函数，这个回调函数由Nanos-lite提供

### 触发自陷操作

测试异常入口地址是否已经设置正确。

定义了宏`HAS_CTE`后, Nanos-lite会在`panic()`前调用`_yield()`来触发自陷操作

- 需要在NEMU中实现`raise_intr()`函数(在`nemu/src/isa/$ISA/intr.c`中定义) 来模拟上文提到的异常响应机制.
- 注意由于异常响应是通用操作，所以直接在`raise_intr()`中实现即可， 而不要在指令的helper函数中实现。

#### 自陷的实现

- sepc是`0x141`，scause是`0x142`，stvec是`0x105`。

  - 上述CSR寄存器放在`CPU_state`结构里面

- 观察到后续需要使用到csrw、ecall等指令，故返回到译码和执行函数中将对应的指令实现。

- 把`__am_asm_trap`函数地址传入指令以写入异常入口地址

  ```c
   asm volatile("csrw stvec, %0" : : "r"(__am_asm_trap));
  ```

- AM中的`_yield()`函数的实现是调用`li a7, -1;`

  - 调用` ecall`后如果发现是a7(x17)=-1进入自陷

- 当NEMU发现a7=-1，接下来就调用`raise_intr()`

- 在`raise_intr()`中，就按照之前说的，完成以下动作：

  - 把当前PC保存到sepc寄存器
  - 在scause寄存器中设置异常号`_EVENT_YIELD`
  - 从stvec寄存器中取出异常入口地址
  - 跳转到异常入口地址

- 自陷操作到此就完成了。

### 保存上下文

跳转到异常入口地址后，需要用到通用寄存器。故在保存通用寄存器之前的内容时需要用到`sw`指令将各个通用寄存器依次压栈

此外，上下文还包括

- 触发异常时的PC和处理器状态
  - 对于riscv32来说, 就是epc/sepc和status/sstatus寄存器, 异常响应机制把它们保存在相应的系统寄存器中, 我们还需要将它们从系统寄存器中读出, 然后保存在堆栈上
- 异常号
  - 对于riscv32来说， 异常号已经由硬件保存在cause/scause寄存器中, 我们还需要将其保存在堆栈上.
- 地址空间
  - riscv32则是将地址空间信息与0号寄存器共用存储空间, 反正0号寄存器的值总是0, 也不需要保存和恢复. 不过目前我们暂时不使用地址空间信息

### 事件分发

- `__am_irq_handle()`函数应把异常原因打包为事件`_Event`，并调用之前初始化CTE时注册的事件处理函数`do_event()`，`do_event`再根据事件异常号进行对应的处理。
  - 在`do_event()`中识别出自陷事件`_EVENT_YIELD`, 然后输出一句话即可, 目前无需进行其它操作.
- 目前只需在`__am_irq_handle()`中根据异常号识别出`_EVENT_YIELD`事件并打包，然后`do_event()`只需输出一句话即可。

### 恢复上下文

- 首先返回到`trap.S`的`__am_asm_trap()`中, 其剩余的代码会重新把栈中存储的上下文信息恢复到寄存器中，然后调用`sret`指令取sepc返回。
  - 需要注意的是，有的异常（比如自陷）需要返回到原sepc+4的位置，而有的异常（比如缺页异常）直接返回原sepc即可，因为还需要再次尝试原指令

### BuG和问题记录

- 第一次跑的时候，发现是译码和执行函数实现的有问题。但是很快的解决了。改的很乱，又重新恢复了pa2的代码
- 在事件分发中，输出的异常号很奇怪，是一个很小的数，并不是一个正常的异常号。在观察log.txt文件后，才发现是之前恢复代码时忘记将寄存器进行编号与宏定义进行对应导致错误。

## 用户程序和系统调用

### 用户程序的加载

- 加载的过程就是把可执行文件中的代码和数据放置在正确的内存位置, 然后跳转到程序入口, 程序就开始执行了. 更具体的, 为了实现`loader()`函数, 我们需要解决以下问题:
  - 可执行文件在哪里?
    - 可执行文件位于ramdisk偏移为0处, 访问它就可以得到用户程序的第一个字节.
  - 代码和数据在可执行文件的哪个位置?
    - 由ELF提供的
  - 代码和数据有多少?
  - "正确的内存位置"在哪里?

- 用户程序的入口位于`navy-apps/libs/libc/src/platform/crt0.c`中的`_start()`函数, 它会调用用户程序的`main()`函数, 从`main()`函数返回后会调用`exit()`结束运行

- 用户程序运行在Nanos-lite上。由于运行时环境的差异, 我们不能把编译到AM上的程序放到操作系统上运行. 为此, 我们准备了一个新的子项目Navy-apps, 专门用于编译出操作系统的用户程序
- 为避免与Nanos-lite的内容冲突，约定用户程序链接到`0x83000000`附近，在`navy-apps/Makefile.compile`中的`LDFLAGS`变量中已经设置了。

- 编译Nanos-lite时会把用户程序等数据编入ramdisk，然后生成镜像文件，并包含进OS中。对于初始的默认测试`dummy`，可执行文件就位于ramdisk的开头，即偏移为0处。
- ELF文件格式了, 它除了包含程序本身的代码和静态数据之外, 还包括一些用来描述它们的信息
  - ELF文件提供了两个视角来组织一个可执行文件, 一个是面向链接过程的section视角, 这个视角提供了用于链接与重定位的信息(例如符号表); 另一个是面向执行的segment视角, 这个视角提供了用于加载可执行文件的信息. 使用`readelf`命令查看elf文件的信息。
    -  一个segment可能由0个或多个section组成, 但一个section可能不被包含于任何segment中.
  - ELF中采用program header table来管理segment，一个表项描述一个segment的所有属性。
    - 需要读取ELF中的program header table，对于`PT_LOAD`的segment，读取其offset，vaddr，filesz，memsz，把offset\~offset+filesz内的段读取到主存的vaddr\~vaddr+memsz内，并把vaddr+filesz~vaddr+memsz内清零。
  - 由于ELF在ramdisk中，框架代码提供了一些访问ramdisk的API（在`nanos-lite/src/ramdisk.c`中定义）。
- loader的功能, 把用户程序加载到正确的内存位置, 然后执行用户程序
  - `loader()`函数在`nanos-lite/src/loader.c`中定义, 其中的`pcb`参数目前暂不使用, 可以忽略
  - 因为ramdisk中目前只有一个文件, `filename`参数也可以忽略.
- 实现后, 在`init_proc()`中调用`naive_uload(NULL, NULL)`, 它会调用你实现的loader来加载第一个用户程序, 然后跳转到用户程序中执行

## OS的运行环境

os作为资源管理者管理着系统中的所有资源并为用户程序提供相应的服务。服务的方式以一种统一的接口【系统接口】来实现，用户程序也只能通过这一接口来请求服务。

## 系统调用

触发一个系统调用的具体过程是怎么样的呢?

- 用户程序通过自陷指令来触发系统调用
  - 在处理自陷的函数中添加处理系统调用的逻辑来实现

- `navy-apps/libs/libos/src/nanos.c`中定义的`_syscall_()`函数
  - 先把系统调用的参数依次放入寄存器中，然后执行自陷指令。
    - a7存放`_syscall_()`的`type`参数，a0~a2存储至多3个参数，a0存放系统调用的返回值。
  - 这里根据不同的ISA定义了不同的宏, 来对它们进行抽象. CTE会将这个自陷操作打包成一个系统调用事件`_EVENT_SYSCALL`, 并交由Nanos-lite继续处理——异常处理函数`do_event()`

- Nanos-lite收到系统调用事件之后, 就会调出系统调用处理函数`do_syscall()`进行处理【`do_event()`中，发现事件类型是`_EVENT_SYSCALL`后，调用`do_syscall()`函数处理】
  - 处理的过程首先通过宏`GPR1`从上下文`c`中获取用户进程之前设置好的系统调用参数
  - 再根据系统调用号进一步调用系统调用函数
- `dummy`程序, 它触发了一个`SYS_yield`系统调用（=1）和3个0参数进行系统调用
  - 待实现
    - 在`nexus-am/am/include/arch/riscv32-nemu.h`中实现正确的`GPR?`宏，用它们从上下文`c`中获得正确的系统调用参数寄存器。
    - 实现OS的`SYS_yield()`系统调用函数（直接调用CTE的`_yield()`然后返回0即可）
    - 设置系统调用的返回值

## OS之上的TRM

为了满足程序的基本计算能力, 需要有哪些条件:

- 机器提供基本的运算指令
  - 靠机器提供——就是pa2中实现的指令系统

- 能输出字符
- 有堆区可以动态申请内存
- 可以结束运行
  - `SYS_exit`系统调用

### 标准输出

输出是通过`SYS_write`系统调用来实现的

- 在`do_syscall()`中识别出系统调用号是`SYS_write`之后, 检查`fd`的值, 如果`fd`是`1`或`2`(分别代表`stdout`和`stderr`), 则把`buf`为首地址的`len`字节输出到串口，并返回输出的字节数。否则返回-1。
- Navy-apps提供了测试程序`hello`。要在Nanos-lite上运行，需要把`nanos-lite/Makefile`中ramdisk的`SINGLE_APP`换成`hello`程序。

### 堆区管理

堆区的使用情况是由libc来进行管理的, 但堆区的大小却需要通过系统调用向操作系统提出更改

- 调整堆区大小是通过`sbrk()`库函数来实现的，用于把用户程序的program break增长`inc`字节，其中`inc`可为负数。
  - program break, 就是用户程序的数据段(data segment)结束的位置。在进行程序链接的时候，`ld`会默认添加一个名为`_end`的符号指示数据段结束的位置。`malloc()`被首次调用时，会通过`sbrk(0)`查询program block的初始位置，之后就可以通过`sbrk()`调整program block的位置了。
  - 在Navy-apps的libc中，`sbrk()`最终会调用`_sbrk()`（在`libs/libos/src/nanos.c`中定义）。
    - 返回-1表示失败
    - 先记录program break的位置为`_end`（用`man 3 end`查询该符号的使用）
    - 被调用时，计算出新的program break
    - 调用`SYS_brk`系统调用让OS设置新的program break
    - 若调用成功，则系统调用返回0。此时更新记录的program break位置，并返回旧位置的值
    - 调用失败则返回-1

## 文件系统

当存在多个程序的时候，对于OS而言，依旧可以通过ramdisk的接口来访问不同的程序。但是当用户程序也要处理很多数据的时候就需要以文件的形式进行处理，用户程序又不知道文件处理ramdisk的哪一个位置。但是把ramdisk的读写接口直接提供给用户程序来使用是不可行的。所以需要OS向用户程序提供文件系统

- 文件的本质就是字节序列, 另外还由一些额外的属性构成.

- 实现的文件系统要求低

  - 每个文件大小固定
  - 写文件不允许超过原有文件大小
  - 文件数量固定，不能创建和删除
  - 没有目录

- 所以可以将每一个文件都固定在ramdisk中的某一个位置

- 用一张“文件记录表”来维护这些信息的脚本

  - 译Nanos-lite就会自动编译Navy-apps里面的所有程序, 并把`navy-apps/fsimg/`目录下的所有内容整合成ramdisk镜像, 同时生成这个ramdisk镜像的文件记录表`nanos-lite/src/files.h`

  - “文件记录表”是一个数组

    ```c
    typedef struct {
      char *name;         // 文件名
      size_t size;        // 文件大小
      size_t disk_offset;  // 文件在ramdisk中的偏移
    } Finfo;
    ```

  - 把`/`也认为是文件名的一部分

- 上述信息可以实现`read`和`write`文件读写操作。但是OS中还是存在些没有名字的文件，于是用文件描述符fd来统一编号。

  - 在Nanos-lite中，由于文件数量固定，所以可以直接使用文件记录表的下标作为fd。
  - 在Nanos-lite中，该偏移量直接由文件记录表维护，可以通过`lseek()`系统调用调整。

- 在`fs.c`中实现文件系统的文件操作，并实现对应的系统调用。

  - 

## 虚拟文件系统

- 所有设备都可以抽象为字节序列，与文件的本质是相似的。

- 对之前实现的文件操作API进行扩展，扩展后的API称为VFS（虚拟文件系统）

- 在Nanos-lite中, 实现VFS的关键就是`Finfo`结构体中的两个读写函数指针

  ```c
  typedef struct {
    char *name;         // 文件名
    size_t size;        // 文件大小
    size_t disk_offset;  // 文件在ramdisk中的偏移
    size_t open_offset;  // 文件被打开之后的读写指针
    ReadFn read;        // 读函数指针
    WriteFn write;      // 写函数指针
  } Finfo;
  ```

  其中`ReadFn`和`WriteFn`分别是两种函数指针，用于指向真正进行读写的函数，并返回成功读写的字节数。

- 由于Nanos-lite中特殊文件很少，因此约定函数指针为`NULL`时，表示该文件是一个普通文件，通过ramdisk的API进行读写。

### 串口抽象

- `stdout`和`stderr`都会输出到串口
  - 通过判断`fd`是否为`1`或`2`, 来决定`sys_write()`是否写入到串口
  - 没有大小约束，同时偏移量就没有意义
- 串口写入的实现在`nanos-lite/src/device.c`中。
- Nanos-lite也不打算支持`stdin`的读入, 因此在文件记录表中设置相应的报错函数即可.

### 输入设备抽象

- 对于系统来说，新的输入可以用文本来抽象，称为事件。定义以下事件，一个事件以`'\n'`结束
  - `t 1234`：返回系统启动后的时间，单位为毫秒
  - `kd RETURN`/`ku A`：按下/松开按键，按键名称全大写，使用AM中定义的按键名
- 把上述事件抽象为文件`/dev/events`，需要支持读操作，用户程序可以从中一次读出一个输入事件。
  - 需要注意的是，一次读取只能返回一个事件，而如果不优先读取键盘事件的话，由于时钟事件可以一直获取，键盘事件就没机会被读取了。

### VGA抽象

- 把显存抽象成文件. 显存本身也是一段存储空间, 它以行优先的方式存储了将要在屏幕上显示的像素
- 显存需要支持`lseek`。
- Nanos-lite和Navy-apps约定，把显存抽象为`/dev/fb`，屏幕大小抽象为`/proc/dispinfo`。
- 在`init_fs()`中对文件记录表中`/dev/fb`大小进行初始化
- 